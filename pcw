#!/usr/bin/perl
$|=1;

our $VERSION = '0.2-r34';

use strict;
use autodie;
use lib 'lib';

#-----------------------------------------------------------------------------
use Carp;
use feature qw/say switch/;
#-----------------------------------------------------------------------------
use Coro;
use AnyEvent;
use Coro::Timer qw/sleep/;
use Getopt::Long qw/:config bundling/;
use File::Spec;
use File::Basename;
#-----------------------------------------------------------------------------
use PCW::Core::Utils qw(get_proxylist);

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
our %mode_config;
our $chan_config;

my @proxies;
my @agents;
my $engine;
#-----------------------------------------------------------------------------
my $common_config = 'config.pl';
my $mode_config;

#-----------------------------------------------------------------------------
# Parse command line arguments
#-----------------------------------------------------------------------------
#-- DEFAULT VALUES
my $chan;
my $mode;
my $loglevel   = 1;
my $verbose    = 0;
my $useragents = 'UserAgents';
my $proxy_file = 'proxy/no';
my $proxy_type = 'http';

sub parse_args()
{
    my $help   = 0;
    my $result = GetOptions(
        'chan=s'     => \$chan,
        'mode=s'     => \$mode,
        'proxy=s'    => \$proxy_file,
        'ua=s'       => \$useragents,
        'cconfig=s'  => \$common_config,
        'mconfig=s'  => \$mode_config,
        'loglevel=i' => \$loglevel,
        'verbose'    => \$verbose,
        'help|?'     => \$help,
    );
    if ($help || !($mode && $chan))
    {
        usage();
        exit 1;
    }
    $mode_config = File::Spec->catfile('configs', "$mode.pl")
        unless $mode_config;
}

sub check_user_error()
{
    Carp::croak("Chan config '$chan' does not exist")
        unless($chan || -e "chans/$chan.pl");

    Carp::croak("Common config '$common_config' does not exist")
        unless($common_config || -e $common_config);

    my $modes_list = 'proxychecker|wipe|delete|autobump';
    Carp::croak("Mode '$mode' does not exist")
        unless($mode =~ /$modes_list/i);

    Carp::croak("Mode '$mode' config does not exist")
        unless(-e "configs/$mode.pl");

    Carp::croak("Proxylist '$proxy_file' does not exist")
        unless($proxy_file && -e $proxy_file);

    Carp::croak("Proxy type '$proxy_type' is not specified")
        unless($proxy_type);

    Carp::croak("Useragents list '$useragents' does not exist")
        unless($useragents && -e $useragents);
}

#-----------------------------------------------------------------------------
# Info
#-----------------------------------------------------------------------------
sub info()
{
    say "Perl Chan Wiper v$VERSION";
    say "~" x 30;
    say "Chan: $chan ". ($chan_config ? "($chan_config->{description})" : "");
    say "Engine: ". $chan_config->{engine};
    say "Work mode: $mode";
    say "Mode config: $mode_config";
    say "Common config: $common_config";
    say "Proxies loaded: ". scalar @proxies;
    say "Browsers loaded: ". scalar @agents;
    say "~" x 30;
    say "Log level: $loglevel";
    say "Verbose output: $verbose";
    say "~" x 30;
}

#-----------------------------------------------------------------------------
# Usage
#-----------------------------------------------------------------------------
sub usage()
{
    my @modes;
    for my $path (glob "PCW/Modes/*.pm")
    {
        next if $path =~ /Common/;
        my ($mode, undef, undef) = fileparse($path, '.pm');
        push @modes, $mode;
    }
    my @chans;
    for my $path (glob "chans/*.pl")
    {
        next if $path =~ /example/;
        my ($chan, undef, undef) = fileparse($path, '.pl');
        push @chans, $chan;
    }
    my @engines;
    for my $path (glob "PCW/Engine/*.pm")
    {
        next if $path =~ /Abstract|Simple/;
        my ($engine, undef, undef) = fileparse($path, '.pm');
        push @engines, $engine;
    }

    local $" = ', ';
    print <<DESU
PerlChanWiper - a multifunction CLI tool for different imageboards

Usage: $0 [chan] [mode]...

Options:
    --chan          Chan name (@chans)
    --mode          Work mode (@modes)
    --proxy         Proxy list (default is '$proxy_file')
    --proxytype     Default proxy protocol (default is '$proxy_type')
    --ua            User agents list file (default is '$useragents')
    --cconfig       Common config file (default is '$common_config')
    --mconfig       Mode config file (default is 'configs/\$mode_name.pl')
    --loglevel      Log level (1-4, 1 â€” the least and default)
    --verbose       Verbose output
    --help          Show this message and exit

Supported chan engines: @engines
Version $VERSION
DESU
}

#-----------------------------------------------------------------------------
# Load
#-----------------------------------------------------------------------------
sub load_configs()
{
    our ($img, $msg, $vid, $captcha_decode);
    require $common_config;
    require $mode_config;  #-- load %mode_config

    $mode_config{img_data} = $img;
    $mode_config{msg_data} = $msg;
    $mode_config{vid_data} = $vid;
    $mode_config{captcha_decode} = $captcha_decode;
}

sub load_proxies()
{
    @proxies = get_proxylist($proxy_file, $proxy_type);
}

sub load_agents()
{
    open my $fh, '<', $useragents;
    @agents = <$fh>;
    close $fh;
}

sub load_chan()
{
    my $package = File::Spec->catfile('chans', "$chan.pl");
    require "$package"; #-- load $chan_config
}

sub load_engine()
{
    my $package = "PCW::Engine::". $chan_config->{engine};
    eval("use $package");
    Carp::croak($@) if ($@);
    $engine = $package->new(%$chan_config, agents => \@agents, loglevel => $loglevel, verbose => $verbose);
}

sub load_mode()
{
    my $package = "PCW::Modes::$mode";
    eval("use $package");
    Carp::croak($@) if ($@);
    $package->new(engine   => $engine,
                  proxies  => \@proxies,
                  conf     => \%mode_config,
                  loglevel => $loglevel,
                  verbose  => $verbose);

}
#-----------------------------------------------------------------------------
sub show_stats($)
{
    my %stats = %{ shift() };
    say "~" x 30;
    for my $k (keys %stats)
    {
        say "$k: $stats{$k}";
    }
}

sub measure_speed($$$)
{
    my ($posted, $start_time, $u) = @_;
    my $d;
    $d = 1   if $u eq 'second';
    $d = 60  if $u eq 'minute';
    $d = 360 if $u eq 'hour';
    return sprintf "%.3f", ($posted / ((time - $start_time)/$d));
}

#-----------------------------------------------------------------------------
# RUN
#-----------------------------------------------------------------------------
parse_args();
check_user_error();
load_configs();     #-- load %mode_config
load_proxies();
load_agents();
load_chan();        #-- load $chan_config
load_engine();
my $m = load_mode();
info();
#-----------------------------------------------------------------------------
my $w = AnyEvent->signal (signal => "INT", cb => sub { $m->stop; });
my $start_time = time;
#-----------------------------------------------------------------------------
$m->start;
while ($m->{is_running})
{
    sleep 1;
}

given ($mode)
{
    when ('ProxyChecker')
    {
        show_stats $m->{stats};
        say @{ $m->{checked} };
    }
    when ('AutoBump')
    {
        show_stats $m->{stats}{bump};
        show_stats $m->{stats}{delete};
    }
    when ('Wipe')
    {
        show_stats $m->{stats};
        say sprintf("speed: %s posts per minute", measure_speed($m->{stats}{posted}, $start_time, 'minute'));
    }
    default
    {
        show_stats $m->{stats};
    }
}
